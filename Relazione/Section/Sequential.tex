%Descrizione algoritmo sequential
%Dal capitolo Jacobi rotation nell'articolo Acosta
%https://tex.stackexchange.com/questions/55054/bordermatrix-with-brackets-instead-of-parentheses
\makeatletter
\def\bbordermatrix#1{\begingroup \m@th
	\global\let\perhaps@scriptstyle\scriptstyle
	\@tempdima 4.75\p@
	\setbox\z@\vbox{%
		\def\cr{%
			\crcr
			\noalign{%
				\kern2\p@
				\global\let\cr\endline
				\global\let\perhaps@scriptstyle\relax
			}%
		}%
		\ialign{$\make@scriptstyle{##}$\hfil\kern2\p@\kern\@tempdima
			&\thinspace\hfil$\perhaps@scriptstyle##$\hfil
			&&\quad\hfil$\perhaps@scriptstyle##$\hfil\crcr
			\omit\strut\hfil\crcr
			\noalign{\kern-\baselineskip}%
			#1\crcr\omit\strut\cr}}%
	\setbox\tw@\vbox{\unvcopy\z@\global\setbox\@ne\lastbox}%
	\setbox\tw@\hbox{\unhbox\@ne\unskip\global\setbox\@ne\lastbox}%
	\setbox\tw@\hbox{$\kern\wd\@ne\kern-\@tempdima\left[\kern-\wd\@ne
		\global\setbox\@ne\vbox{\box\@ne\kern2\p@}%
		\vcenter{\kern-\ht\@ne\unvbox\z@\kern-\baselineskip}\,\right]$}%
	\null\;\vbox{\kern\ht\@ne\box\tw@}\endgroup}
\def\make@scriptstyle#1{\vcenter{\hbox{$\scriptstyle#1$}}}
\makeatother

\label{sec:Sequential}

La rotazione di Jacobi è una rotazione di un sottospazio bidimensionale in uno spazio $n$-dimensionale, denotato da \textbf{J}. Dopo l'applicazione di questa trasformazione, una coppia di elementi di una matrice simmetrica  $\mathbf{B} \in \mathbb{R}^{n \times n}$ sono azzerati, come indicato in $\mathbf{B} \longmapsto \mathbf{J^TBJ} = \mathbf{B}'$ dove $c = \cos (\theta)$, $s = \sin (\theta)$ e $\theta$ è l'angolo di rotazione nel piano $(i, j)$. Solo le righe $i$-esima e $j$-esima di $\mathbf{B}$ sono interessate. In modo simile, solo le colonne $j$-esima e $i$-esima sono interessate. Gli elementi $b'_{ij}$, $b'_{ji}$,  $b'_{ii}$ e $b'_{jj}$ in $\mathbf{B}$ vengono utilizzati per calcolare gli angoli nelle matrici di rotazione che eliminano gli elementi $b'_{ij}$ e $b'_{ji}$ come mostrato in Eq.~\eqref{eq:J_matrix}. 
\begin{equation} \label{eq:J_matrix}
%
\mathbf{J}(i,j,\theta) = \bbordermatrix{
	& & & i& &j &  & \cr
	&1 & \dots & 0 & \dots & 0 &\dots & 0 \cr
	&\vdots & \ddots & \vdots & & \vdots & & \vdots\cr
	i&0 & \dots & c & \dots & s & \dots & 0 \cr
	&\vdots & & \vdots & & \vdots & & \vdots\cr
	j&0 & \dots & -s & \dots & c & \dots & 0\cr
	&\vdots & & \vdots & & \vdots & \ddots & \vdots\cr
	&0 & \dots & 0 & \dots & 0 & \dots & 1\cr
}
%
\end{equation}
L'algoritmo Jacobi esegue una sequenza di aggiornamenti della matrice $\mathbf{B}$ che viene ortogonalizzata, ogni nuova matrice $\mathbf{B}$ è più diagonale rispetto alla predecedente.  Quando gli elementi fuori della diagonale sono abbastanza piccoli, possono essere considerati nulli. In particolare, ogni rotazione Jacobi comporta una pre-moltiplicazione e una post-moltiplicazione di $\mathbf{B}$ per matrici ortogonali. In generale, vengono eseguite $(n^2 - n)/2$ rotazioni (nel caso di una matrice simmetrica) cercando di rendere zero tutti gli elementi fuori diagonale. Queste $(n^2 - n)/2$ transformazioni costituiscono una scansione (sweep). Comunemente, le rotazioni di Jacobi vengono applicate utilizzando uno dei seguenti approcci: esecuzione di rotazioni cicliche per riga o per colonna. In questi approcci, la coppia $(i, j)$ è selezionata riga per riga o colonna per colonna, rispettivamente. Ad esempio, se $n = 4$, la sequenza di rotazione è: $(i, j) = (1,2), (1,3), (1,4), (2, 3), (2,4), (3,4)$.
\cite{Acosta:SVD}

Viene ora mostrata l'implementazione in CUDA dell'algoritmo sequenziale. Il kernel che esegue l'algoritmo One-Sided Jacobi sequential è compreso in un ciclo \textbf{while} mostrato di seguito.
\begin{lstlisting}[caption=Loop algoritmo sequential,label=code:sequential_loop]
while (!host_exit_flag) {
	++iter;
	host_exit_flag = true;
	cudaMemcpy( exit_flag, &host_exit_flag, sizeof(bool), cudaMemcpyHostToDevice);
	for (int j = columns - 1; j >= 1; --j)
		for (int i = j - 1; i >= 0; --i) {	
			rotate<<<1, rows>>> (B, i, j, rows, exit_flag);
	}
}
\end{lstlisting}
La variabile \textit{iter} contiene le iterazioni necessarie per portare a termine con successo l'algoritmo di One-Sided Jacobi rotation.

\textit{host\_exit\_flag} contiene il flag che permettere di uscire dal ciclo \textbf{while} quando le colonne della matrice sono sufficientemente ortogonali.

La coppia \textit{i} e \textit{j} rappresenta la coppia di colonne i-esima e j-esima che sta ruotando, \textit{B} contiene la matrice da cui estrarre i valori singolari.

Il kernel \textit{rotate} esegue la One-Sided Jacobi rotation descritta nel capitolo~\ref{sec:OneSidedJacobi}. Per chiamare questa funzione, viene usato un solo blocco e un numero di threads pari a \textit{rows}, come si può vedere dalle parentesi angolari, in modo che tramite l'indice del thread si possa accedere al k-esimo elemento della coppia i-esima e j-esima di vettori colonna. Il kernel è definito come di seguito
\begin{lstlisting}[numbers=left]
__global__ void rotate (float * B, int i, int j, int  rows, bool * exit_flag){
	int k = threadIdx.x; 
	__shared__ float alpha, beta, gamm, limit, tao, t, c, s;
	float *pi, *pj;
	if (k < rows) {
		alpha = beta = gamm = 0;
		__syncthreads();
		pi = B + rows * i + k;
		pj = B + rows * j + k;
		atomicAdd(&alpha, *pi * *pi);
		atomicAdd(&beta, *pj * *pj);	
		atomicAdd(&gamm, *pi * *pj);
		__syncthreads();
		if (* exit_flag) {
			limit = fabsf(gamm) / sqrtf(alpha * beta);
			if (limit > eps) 
				* exit_flag = false;
		}
		tao = (beta - alpha) / (2 * gamm);
		t = sign (tao) / (fabsf(tao) + sqrtf(1 + tao * tao)); 
		c = expf(-0.5f * log1pf(t * t)); 
		s = c * t;
		const float tmp = *pi;
		*pi = c * tmp - s * *pj;
		*pj = s * tmp + c * *pj;
	}
}
\end{lstlisting}
Alla riga 3, le variabili \textit{alpha}, \textit{beta}, \textit{gamm}, \textit{limit}, \textit{tao}, \textit{t}, \textit{c} e \textit{s} con attributo \textit{\_\_shared} risiedono nella memoria shared in quanto sono comuni a tutti i threads del blocco.

Nella riga 6 si inizializzano le variabili \textit{alpha}, \textit{beta} e \textit{gamm} a zero. 

Alla linea 7, \textit{\_\_syncthreads}() attende che tutti i thread nel blocco abbiano raggiunto questo punto e tutti gli accessi alla memoria globale e shared effettuati da questi thread prima di \textit{\_\_syncthreads}() sono visibili a tutti i thread nel blocco.

La matrice \textit{B} è formata da vettori colonna e i puntatori \textit{pi} e \textit{pj} puntano alla locazione di memoria in cui è contenuto l'elemento k-esimo, cioè alla riga k-esima, della coppia di vettori colonna i-esimo e j-esimo. 

La funzione \textit{atomicAdd}, presente nelle righe 10, 11 e 12, è definita come
\begin{lstlisting}
float atomicAdd(float* address, float val);
\end{lstlisting}
legge la variabile floating point a 32 bit \textit{old} memorizzata all'indirizzo di memoria \textit{address} nella memoria globale o shared, calcola (\textit{old} + \textit{val}), e salva il risultato allo stesso indirizzo di memoria. Queste tre operazioni sono eseguite in una sola operazione atomica. La funzione ritorna \textit{old}. Nel kernel, viene usata per calcolare la norma del vettore colonna i-esimo e j-esimo e il loro prodotto scalare e scriverlo rispettivamente in \textit{alpha}, \textit{beta} e \textit{gamm}.

Se la variabile \textit{exit\_flag} è true, si calcola \textit{limit} e se è maggiore di \textit{eps} dichiarata globalmente
\begin{lstlisting}[caption=Dichiarazione della variabile \textit{eps},label=code:eps]
static const float eps = 1e-4;
\end{lstlisting}
allora si porta \textit{exit\_flag} false.

Si procede con il calcolo di \textit{c} e \textit{s} che rappresentano rispettivamente la funzione $\sin(\theta)$ e $\cos(\theta)$ descritta nella formula~\eqref{eq:J_matrix}.

Alle linee 24 e 25 si ruota la matrice moltiplicando opportunamente il contenuto dei puntatori \textit{pi} e \textit{pj} per \textit{c} e \textit{s}.

Successivamente, nel programma viene richiamato il kernel \textit{computeSingVals} che effettua il calcolo dei valori singolari. Vengono usati un numero di blocchi pari a \textit{columns} e di threads pari a \textit{rows}, in modo che tramite l'indice del blocco e dei thread si possa accedere rispettivamente ad un j-esimo vettore colonna e ad un suo k-esimo elemento.
\begin{lstlisting}
computeSingVals<<<columns, rows>>>(B, AUX1, rows, columns);
\end{lstlisting}
dove \textit{AUX1} è un array che contiene i valori singolari.

Il kernel \textit{computeSingVals} viene definito come
\begin{lstlisting}[caption=Kernel per il calcolo dei valori singolari,label=code:computeSingVals]
__global__ void computeSingVals (float * B, float * AUX1, int rows, int columns){
	int k = threadIdx.x;
	int j = blockIdx.x;
	__shared__ float t;
	if ((j < columns) && (k < rows)){
		float *pj = B + rows * j + k;
		t = 0;
		atomicAdd(&t, *pj * *pj);
		AUX1[j] = sqrtf(t);
	}
}
\end{lstlisting}
La variabile 32-bit floating point \textit{t}, inizializzata a zero, contiene il quadrato della norma del vettore colonna j-esimo. 

Per ottenere i valori singolari occorre fare la radice quadrata di \textit{t} tramite la funzione \textit{sqrtf}.