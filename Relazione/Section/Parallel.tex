%Descrizione algoritmo parallel
%Dal capitolo PARALLELIZING THE ONE-SIDED JACOBI nell'articolo Romer
Parallelizzare la One-Sided Jacobi implica il partizionamento di $n(n-1)/2$ coppie di colonne che devono essere ortogonali a ciascuna scansione (sweep) in gruppi di coppie di colonne indipendenti. Ogni sweep viene quindi elaborato un set alla volta, ortogonalizzando in parallelo le coppie di colonne all'interno del set corrente.

Le coppie di colonne per ciascun set vengono generate utilizzando un algoritmo di pianificazione round-robin. Concettualmente, ogni round rappresenta un set e gli abbinamenti all'interno di un round corrispondono agli abbinamenti di colonne all'interno di quel set. Ad esempio, di seguito sono riportati tutti i possibili set contenenti le rispettive coppie di colonne per $n = 6$:
\begin{center}
	Set 1 = $\{(1,2),(3,4),(5,6)\}$\\
	Set 2 = $\{(1,4),(2,6),(3,5)\}$\\
	Set 3 = $\{(1,6),(2,3),(4,5)\}$\\
	Set 4 = $\{(1,5),(2,4),(3,6)\}$\\
	Set 5 = $\{(1,3),(2,5),(4,6)\}$\\
\end{center}
In generale, ogni set contiene $\hat{n}/2$ coppie di colonne ortogonalizzate in parallelo, dove $\hat{n}$ è il prossimo numero intero pari maggiore o uguale a $n$. Se $n$ è dispari, quindi ogni set avrà una colonna accoppiata con una colonna "fittizia"; le coppie che contengono la colonna fittizia non sono ortogonali. In base a questo schema, sono necessari $\hat{n}/2 - 1$ set per completare una sweep completa.

La coppia di colonne $(p', q')$ ortogonalizzata dalla $i-$esima rotazione in un set viene calcolata direttamente dalla coppia di colonne $(p, q)$ corrispondente ortogonalizzata dalla $i-$esima rotazione nel set precedente. In pratica, questo schema è più adatto per l'esecuzione su una GPU in cui la larghezza di banda di calcolo supera notevolmente la larghezza di banda di memoria. \cite{Romer:SVD}

%Dal capitolo Parallel-Order Jacobi algorithm nell'articolo Acosta
Nelle tradizionali implementazioni sequenziali dell'algoritmo Jacobi, il parallelismo non viene sfruttato, principalmente a causa della dipendenza dei dati di una rotazione con la sua precedente. L'algoritmo Jacobi parallelo sfrutta il massimo parallelismo per la decomposizione di una matrice simmetrica. Questo algoritmo richiede un numero di step pari a $n - 1$, in cui in ogni step si compiono $n/2$ rotazioni. Tutte le rotazioni all'interno di uno step possono essere eseguite in parallelo. \cite{Acosta:SVD}

%Dal capitolo IMPLEMENTING THE SVD USING CUDA nell'articolo Romer
Si è usato CUDA per implementare una SVD parallela basata sul metodo One-Sided Jacobi descritto in~\ref{sec:OneSidedJacobi}. La matrice di input $A~(m \times n)$ è una matrice reale in cui $m \geq n$. Se $m < n$, la SVD di A può essere calcolata dalla SVD di $A^T = V \Sigma U^T$. Le matrici di input sono salvate in column-major order e single-precision floating point. \cite{Romer:SVD}

Viene ora mostrata l'implementazione in CUDA dell'algoritmo parallel. Il codice che richiama il kernel che esegue l'algoritmo One-Sided Jacobi parallel è il seguente.
\begin{lstlisting}[caption=Loop algoritmo parallelo,label=code:parallel_loop]
while(!host_exit_flag) {
	++iter;
	host_exit_flag = true; 
	cudaMemcpy(dev_exit_flag, &host_exit_flag, sizeof(bool), cudaMemcpyHostToDevice);
	for(int set = 0; set < cols; set++) {
		scheduling<<<1, 1>>> (dev_v1, dev_v2, cols);
		round <<<cols/2, rows>>> (dev_B, dev_v1, dev_v2, cols, rows, dev_exit_flag);		
	}
	cudaMemcpy( &host_exit_flag, dev_exit_flag, sizeof(bool), cudaMemcpyDeviceToHost);
}
\end{lstlisting}
Le variabili \textit{host\_exit\_flag}, \textit{iter} e \textit{B} svolgono le stesse funzioni descritte nel codice~\ref{code:parallel_loop}.

La variabile \textit{set} rappresenta il round attuale dello scheduling round robin. Come spiegato in precedenza, il numero di set necessari per formare tutte le possibili combinazioni sono $n-1$, dove $n$ è il numero di colonne della matrice originale.

I vettori \textit{v1} e  \textit{v2} servono a rappresentare l'indice delle coppie di colonne della matrice da ruotare. Per ogni set gli elementi dei vettori con lo stesso indice rappresentano una coppia di colonne da ortogonalizzare mutualmente. L'aggiornamento dei vettori \textit{v1} e  \textit{v2} viene effettuato dal kernel \textit{scheduling}.

Il kernel \textit{scheduling} ha lo scopo di ruotare i vettori \textit{v1} e  \textit{v2} ad ogni iterazione del ciclo in cui viene incrementato il valore di \textit{set}. Infatti, per effettuare l'algoritmo di round robin è sufficiente tenere fisso il primo elemento del primo vettore e routare gli altri come se fossero un unico vettore. Quindi, l'elemento 0 che rappresenta la prima colonna sarà sempre alla prima posizione del primo vettore. Gli altri elementi dello stesso vettore scorreranno verso destra, mentre il secondo vettore esegue uno shift verso sinistra. L'elemento uscente dal secondo vettore viene spostato nel posto vacante lasciato dall'elemento 1 di \textit{v1} mentre l'ultimo elemento del primo vettore diventa l'ultimo del secondo. Supponendo di avere una matrice con 6 colonne, gli array \textit{v1} e \textit{v2} contengono gli interi da 1 a 3 e da 4 a 6 rispettivamente. In questo caso, l'algoritmo di round robin è presentato nella figura~\ref{fig:Round_Robin}.
\begin{figure}[H]
	\centering
	\subfloat[Step 1]{
	\begin{tikzpicture}[
	squarednode/.style={rectangle},%draw=white, fill=white, very thick, minimum size=5mm
	]
	%Nodes
	\node[squarednode]      (first)             	         	        {1};
	\node[squarednode]      (second)   	    	[right=of first] {2};
	\node[squarednode]      (third)       		[right=of second] {3};
	\node[squarednode]      (fourth)     	  	[below=of third] {4};
	\node[squarednode]      (fifth)     	  	[left=of fourth] {5};
	\node[squarednode]      (sixth)     	  	[left=of fifth] {6};
	%Lines
	\draw[->] (second.east) -- (third.west);
	\draw[->] (third.south) -- (fourth.north);
	\draw[->] (fourth.west) -- (fifth.east);
	\draw[->] (fifth.west) -- (sixth.east);
	\draw[->] (sixth.north) -- (second.south);
	\end{tikzpicture}
	}
	\subfloat[Step 2]{
	\begin{tikzpicture}[
	squarednode/.style={rectangle},%draw=white, fill=white, very thick, minimum size=5mm
	]
	%Nodes
	\node[squarednode]      (first)             	         	        {1};
	\node[squarednode]      (second)   	    	[right=of first] {6};
	\node[squarednode]      (third)       		[right=of second] {2};
	\node[squarednode]      (fourth)     	  	[below=of third] {3};
	\node[squarednode]      (fifth)     	  	[left=of fourth] {4};
	\node[squarednode]      (sixth)     	  	[left=of fifth] {5};
	%Lines
	\draw[->] (second.east) -- (third.west);
	\draw[->] (third.south) -- (fourth.north);
	\draw[->] (fourth.west) -- (fifth.east);
	\draw[->] (fifth.west) -- (sixth.east);
	\draw[->] (sixth.north) -- (second.south);
	\end{tikzpicture}
}
\subfloat[Step 3]{
	\begin{tikzpicture}[
	squarednode/.style={rectangle},%draw=white, fill=white, very thick, minimum size=5mm
	]
	%Nodes
	\node[squarednode]      (first)             	         	        {1};
	\node[squarednode]      (second)   	    	[right=of first] {5};
	\node[squarednode]      (third)       		[right=of second] {6};
	\node[squarednode]      (fourth)     	  	[below=of third] {2};
	\node[squarednode]      (fifth)     	  	[left=of fourth] {3};
	\node[squarednode]      (sixth)     	  	[left=of fifth] {4};
	%Lines
	\draw[->] (second.east) -- (third.west);
	\draw[->] (third.south) -- (fourth.north);
	\draw[->] (fourth.west) -- (fifth.east);
	\draw[->] (fifth.west) -- (sixth.east);
	\draw[->] (sixth.north) -- (second.south);
	\end{tikzpicture}
}
\newline
\subfloat[Step 4]{
	\begin{tikzpicture}[
	squarednode/.style={rectangle},%draw=white, fill=white, very thick, minimum size=5mm
	]
	%Nodes
	\node[squarednode]      (first)             	         	        {1};
	\node[squarednode]      (second)   	    	[right=of first] {4};
	\node[squarednode]      (third)       		[right=of second] {5};
	\node[squarednode]      (fourth)     	  	[below=of third] {6};
	\node[squarednode]      (fifth)     	  	[left=of fourth] {2};
	\node[squarednode]      (sixth)     	  	[left=of fifth] {3};
	%Lines
	\draw[->] (second.east) -- (third.west);
	\draw[->] (third.south) -- (fourth.north);
	\draw[->] (fourth.west) -- (fifth.east);
	\draw[->] (fifth.west) -- (sixth.east);
	\draw[->] (sixth.north) -- (second.south);
	\end{tikzpicture}
}
\subfloat[Step 5]{
	\begin{tikzpicture}[
	squarednode/.style={rectangle},%draw=white, fill=white, very thick, minimum size=5mm
	]
	%Nodes
	\node[squarednode]      (first)             	         	        {1};
	\node[squarednode]      (second)   	    	[right=of first] {3};
	\node[squarednode]      (third)       		[right=of second] {4};
	\node[squarednode]      (fourth)     	  	[below=of third] {5};
	\node[squarednode]      (fifth)     	  	[left=of fourth] {6};
	\node[squarednode]      (sixth)     	  	[left=of fifth] {2};
	%Lines
	\draw[->] (second.east) -- (third.west);
	\draw[->] (third.south) -- (fourth.north);
	\draw[->] (fourth.west) -- (fifth.east);
	\draw[->] (fifth.west) -- (sixth.east);
	\draw[->] (sixth.north) -- (second.south);
	\end{tikzpicture}
}
\caption{Algoritmo Round Robin} \label{fig:Round_Robin}
\end{figure}
Ogni iterazione di questo algoritmo viene effettuata sul device. In questo modo, non ci sarà la necessità di copiare i vettori da host a device e viceversa. Il costo computazionale per lanciare un kernel compensa di gran lunga quello che sarebbe necessario per le \textit{cudaMemcpy}.
\begin{lstlisting}
__global__ void scheduling (int *v1, int *v2, int cols){
	int tmp = v2[0];
	for (int i = 0; i < (cols/2) - 1; i++)
	v2[i] = v2[i+1];	
	v2[cols/2 - 1] = v1[cols/2 - 1];
	for (int i = (cols/2) -1; i > 1; i--)
	v1[i] = v1[i-1];	
	v1[1] = tmp;
}
\end{lstlisting}

Il kernel \textit{round} ortogonalizza contemporaneamente ogni coppia di colonne in un set, usando una grid $n/2$ blocchi, dove $n$ è il numero di colonne della matrice. Per ogni set, l'm-esimo blocco è responsabile dell'ortogonalizzazione delle colonne $a_{pm}$ e $a_{qm}$, dove $(p_b, q_b)$ è l'm-esima coppia di colonne del set corrente.

Ogni blocco è composto da un numero di thread pari alle righe della matrice. Con un thread allocato per ogni elemento della coppia di vettori colonna, è possibile aggiornare ogni componente del vettore in parallelo, incrementando il parallelismo.\cite{Romer:SVD}

Nei capitoli~\ref{sec:Global},~\ref{sec:Semi_Shared} e~\ref{sec:Shared} sono presentate tre varianti del kernel \textit{round} a seconda della memoria in cui viene immagazzinata la matrice \textit{B}.

Il calcolo dei valori singolari è eseguito dal kernel~\textit{computeSingVals}, codice~\ref{code:computeSingVals}, precedentemente descritto.