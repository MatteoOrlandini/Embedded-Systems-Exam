%Descrizione algoritmo Semi Shared Memory
\label{sec:Semi_Shared}
In questa implementazione le variabili \textit{alpha}, \textit{beta}, \textit{gamm}, \textit{limit}, \textit{tao}, \textit{t}, \textit{c}, \textit{s}, \textit{i} e \textit{j} sono contenute nella shared memory e sono identificate dall'attributo \textit{\_\_shared}. I puntatori \textit{pi} e \textit{pj} che contengono l'indirizzo di memoria degli elementi della coppia di vettori colonna i-esimo e j-esimo non sono contenuti invece contenuti nella shared memory.
\begin{lstlisting}
__global__ void round (float *B, int *v1, int *v2, int cols, int rows, bool * exit_flag) {
	int blockId = blockIdx.x; //max(blockId) = (cols/2) - 1
	int threadId = threadIdx.x; //max(blockId) = rows - 1
	float * pi, *pj;
	__shared__ float alpha, beta, gamm, limit, tao, t, c, s;
	__shared__ int i, j;
	if ((blockId < cols/2) && (threadId < rows)){
		i = *(v1 + blockId);
		j = *(v2 + blockId);
		pi = B + rows * i + threadId;
		pj = B + rows * j + threadId;
		alpha = beta = gamm = 0;
		__syncthreads();
		atomicAdd(&alpha, *pi * *pi);
		atomicAdd(&beta, *pj * *pj);	
		atomicAdd(&gamm, *pi * *pj);
		__syncthreads();
		if ( *exit_flag) {
			limit = fabsf(gamm) / sqrtf(alpha * beta);
			if (limit > eps){
				*exit_flag = false;
			}
		} 
		tao = (beta - alpha) / (2 * gamm);
		t = sign (tao) / (fabsf(tao) + sqrtf(1 + tao * tao)); 
		c = expf(-0.5f * log1pf(t * t));
		s = c * t;
		const float tmp = *pi;
		*pi = c * tmp - s * *pj;
		*pj = s * tmp + c * *pj;
	}
}
\end{lstlisting}