\label{sec:OneSidedJacobi}
Per effettuare la SVD di una matrice, sono stati sviluppati numerosi algoritmi con lo scopo di ottimizzare il numero di operazioni svolte dalla macchina.
Uno di quelli più usati è l'algoritmo di Jacobi con la sua variante One Sided Jacobi. L'approccio utilizzato è quello di applicare successive rotazione alla matrice originale, in modo da azzerare le componenti che si trovino al di fuori della diagonale. Tramite diverse iterazioni, si ottiene come risultato finale una matrice diagonale contenente i valori singolari richiesti.
\subsubsection{Jacobi rotation}
\label{sec:Jacobi_rotation}
La rotazione di Jacobi è una operazione che consente di azzerare selettivamente elementi specifici di una matrice. Tramite una rotazione in due dimensioni $p$ e $q$ vengono azzerati gli elementi $(p,q)$ e $(q,p)$ della matrice.

L'operazione si basa sull'utilizzo della matrice di Jacobi $\mathbf{J}(p,q,\theta)$ del tipo:
\begin{equation}
\mathbf{J}(p,q,\theta)=\begin{bmatrix}
1 &  &  &  &  &  & \\
& \ddots &  &  &  & 0 & \\
&  & c & \cdots & -s &  & \\
&  & \vdots & \ddots & \vdots &  & \\
&  & s & \cdots & c &  & \\
& 0 &  &  &  & \ddots & \\
&  &  &  &  &  & 1
\end{bmatrix}
\end{equation}
dove $c=\cos(\theta)$ e $s=\sin(\theta)$, vengono applicati solo nelle dimensioni $p$ e $q$.

Premoltiplicare un vettore per $\mathbf{J}(p,q,\theta)^T$ equivale a ruotarlo in senso antiorario di un angolo $\theta$ nel piano $(p,q)$. Questa rotazione produce un vettore risultante nel quale la componente q è stata azzerata. Infatti se $\mathbf{x}\in\mathbb{R}^{n}$ e
\begin{equation}
\mathbf{y}=\mathbf{J}(p,q,\theta)^T	\cdot \mathbf{x}
\end{equation}
allora
\begin{eqnarray}
y_p=cx_p-sx_q\\
y_q=sx_p+cx_q\label{yq}\\
y_i=x_i, i\neq p,q
\end{eqnarray}
Da \eqref{yq} si nota che $y_q$ può essere azzerata ponendo:
\begin{equation}
c=\frac{x_p}{\sqrt{x_p^2+x_q^2}},\quad s=\frac{-x_q}{\sqrt{x_p^2+x_q^2}}
\end{equation}
Per una matrice $\mathbf{A}$ simmetrica, è possibile azzerare le componenti $(p,q)$ e $(q,p)$ applicando la\eqref{jacrot}.
\begin{equation}\label{jacrot}
\mathbf{B}=\mathbf{J}(p,q,\theta)^T\mathbf{A}\mathbf{J}(p,q,\theta)
\end{equation}

\subsubsection{Algoritmo One Sided Jacobi}
\label{sec:Algoritmo_One_Sided_Jacobi}
L'idea base per questo algoritmo è quella di ruotare le colonne i e j di $\mathbf{A}$ per renderle ortogonali. In questo modo, le colonne i e j di $\mathbf{A}^T\mathbf{A}$ saranno implicitamente ortogonali.

Sia $\mathbf{J}(p,q,\theta)$ la matrice di rotazione che, applicata ad $\mathbf{A}$, produce:
\begin{equation}
\mathbf{B}=\mathbf{AJ}
\end{equation}
dove le colonne i e j di $\mathbf{B}$ sono date da
\begin{eqnarray}
b_{:i}=ca_{:i}-sa_{:j}\\
b_{:j}=sa_{:i}+ca_{:j}
\end{eqnarray}
l'elemento $(B^TB)_{ij}$ sarà
\[
(B^TB)_{ij}=b_{:i}^Tb_{:j}=(ca_{:i}-sa{:j})^T(sa_{:i}+ca_{:j})
\]
assumendo $(B^TB)_{ij}=0,i\neq j$ si ottiene
\[
cs(||a_{:i}||^2-||a_{:j}||^2)+(c^2-s^2)(sa_{:i}+ca_{:j})
\]
Dividendo per $c^2$ e considerando
\begin{equation*}
\begin{aligned}
t=s/c\\
\alpha = ||a_{:i}||^2\\
\beta = ||a_{:j}||^2\\
\gamma = a_{:i}^Ta_{:j}\\
\tau =(\beta - \alpha)/2\gamma
\end{aligned}
\end{equation*}
si ottiene la seguente espressione:
\begin{equation}
t^2+2\tau t-1=0
\end{equation}
Risolvendo e scegliendo come soluzione la radice con il minore valore assoluto,
\begin{equation}
t=min|-\tau\pm\sqrt{1+\tau^2}|
\end{equation}
ottieniamo i valori di c e s che rappresentano coseno e seno nella matrice di rotazione:
\begin{equation}
c=\frac{1}{\sqrt{1+t^2}},\quad s=ct
\end{equation}
Con c e s così calcolati, gli elementi $(B^TB)_{ij}$ e $(B^TB)_{ji}$ saranno uguali a zero.\cite{Turchetti:SVDAlgorithms}



